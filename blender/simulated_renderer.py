"""
Simulated Blender Renderer - For when Blender is not available
Renderizador simulado de Blender - Para cuando Blender no est√° disponible
"""

import os
import json
import time
from pathlib import Path
from typing import List, Any

from parser.scene_builder import SceneConfig

class SimulatedBlenderRenderer:
    """Simulated Blender renderer for development and testing"""
    
    def __init__(self, resolution: str = "1080p", fps: int = 30, output_format: str = "mp4"):
        self.resolution = self._parse_resolution(resolution)
        self.fps = fps
        self.output_format = output_format
        
        print(f"üé¨ Modo simulado configurado: {self.resolution[0]}x{self.resolution[1]} @ {self.fps}fps")
    
    def _parse_resolution(self, resolution: str) -> tuple:
        """Parse resolution string to width, height tuple"""
        resolutions = {
            "720p": (1280, 720),
            "1080p": (1920, 1080),
            "4k": (3840, 2160)
        }
        return resolutions.get(resolution, (1920, 1080))
    
    def render_video(self, scenes: List[SceneConfig], audio_files: List[str], output_dir: str) -> str:
        """Simulate video rendering"""
        print(f"üîç DEBUG: Recibidas {len(scenes)} escenas de tipo {type(scenes[0]).__name__ if scenes else 'N/A'}")
        
        # Verify scene types
        for i, scene in enumerate(scenes):
            print(f"  Escena {i+1}: {type(scene).__name__}")
            if not hasattr(scene, 'name'):
                print(f"    ‚ùå ERROR: Escena {i+1} no tiene atributo 'name'")
                print(f"    Tipo real: {type(scene)}")
                print(f"    Contenido: {scene}")
                raise AttributeError(f"Scene {i+1} is not a SceneConfig object")
            else:
                print(f"    ‚úÖ name: {scene.name}")
                print(f"    ‚úÖ duration_seconds: {scene.duration_seconds}")
        
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        # Generate unique output filename
        output_file = output_path / f"procedure_simulated.{self.output_format}"
        
        print(f"üé• Iniciando renderizado de {len(scenes)} escenas")
        print("üé≠ MODO SIMULADO - Generando metadata de renderizado...")
        
        # Simulate processing time
        time.sleep(1)
        
        # Create simulation metadata
        metadata = {
            "simulation": True,
            "resolution": f"{self.resolution[0]}x{self.resolution[1]}",
            "fps": self.fps,
            "format": self.output_format,
            "total_scenes": len(scenes),
            "total_duration": sum(scene.duration_seconds for scene in scenes),
            "scenes": []
        }
        
        # Process each scene
        for i, scene in enumerate(scenes):
            scene_metadata = {
                "name": scene.name,
                "duration": scene.duration_seconds,
                "objects_count": len(scene.objects),
                "animations_count": len(scene.animations),
                "overlays_count": len(scene.overlays),
                "camera_type": scene.camera.type.value if hasattr(scene.camera.type, 'value') else str(scene.camera.type),
                "audio_file": audio_files[i] if i < len(audio_files) else None
            }
            metadata["scenes"].append(scene_metadata)
            
            print(f"üìπ Procesando escena {i+1}/{len(scenes)}: {scene.name}")
            time.sleep(0.5)  # Simulate processing
        
        # Create metadata file
        metadata_file = output_path / f"procedure_simulated_metadata.json"
        with open(metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
        
        # Create simulated video file (empty placeholder)
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Simulated video file\n")
            f.write(f"# This would be a {self.output_format.upper()} video file\n")
            f.write(f"# Resolution: {self.resolution[0]}x{self.resolution[1]}\n")
            f.write(f"# Duration: {metadata['total_duration']:.1f} seconds\n")
            f.write(f"# Scenes: {len(scenes)}\n")
            f.write(f"# Generated by Q-AVIOGEN in simulation mode\n")
        
        print(f"‚úÖ Simulaci√≥n completada")
        print(f"üìÅ Metadata: {metadata_file}")
        print(f"üìÅ Video placeholder: {output_file}")
        
        return str(output_file)

def get_renderer_class():
    """Get the appropriate renderer class based on availability"""
    try:
        import bpy
        from .enhanced_renderer import EnhancedBlenderRenderer
        return EnhancedBlenderRenderer
    except ImportError:
        print("‚ö†Ô∏è Blender no disponible - usando modo simulado")
        print("üí° Para renderizado real, ejecute desde Blender: blender --python main.py")
        return SimulatedBlenderRenderer
